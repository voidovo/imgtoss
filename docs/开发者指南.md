# 开发者指南

本指南面向想要参与 ImgToss 开发或基于 ImgToss 进行二次开发的开发者。详细介绍了项目架构、开发环境搭建、代码规范和贡献流程。

## 技术架构概述

ImgToss 采用现代化的前后端分离架构，结合了 Web 技术和桌面应用的优势：

```
┌─────────────────────────────────────────────────────────┐
│                    ImgToss 架构图                        │
├─────────────────────────────────────────────────────────┤
│  Frontend (Next.js)          │  Backend (Tauri + Rust)  │
│  ┌─────────────────────────┐ │ ┌─────────────────────────┐│
│  │ Next.js 15 + React 19   │◄┤ │ Tauri 2 Framework       ││
│  │ TypeScript + Tailwind   │ │ │ Rust Services Layer     ││
│  │ Radix UI Components     │ │ │ SQLite Database         ││
│  │ Custom Hooks & Context  │ │ │ Async File Operations   ││
│  └─────────────────────────┘ │ └─────────────────────────┘│
├─────────────────────────────────────────────────────────┤
│              Communication Layer                         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ Tauri Commands Bridge (JSON-RPC over IPC)           │ │
│  │ Type-safe API with full TypeScript integration     │ │
│  └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│                External Services                        │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────────┐│
│  │阿里云OSS │ │腾讯云COS │ │ AWS S3  │ │  S3兼容服务     ││
│  └─────────┘ └─────────┘ └─────────┘ └─────────────────┘│
└─────────────────────────────────────────────────────────┘
```

### 关键技术栈

#### 前端技术
- **Next.js 15**: App Router + React Server Components
- **React 19**: 最新的 React 特性和 Hooks
- **TypeScript**: 完整的类型安全保障
- **Tailwind CSS**: 实用优先的样式框架
- **Radix UI**: 无障碍访问的组件基础库
- **React Hook Form**: 高性能表单管理
- **Zustand**: 轻量级状态管理

#### 后端技术
- **Tauri 2**: 跨平台桌面应用框架
- **Rust**: 系统级编程语言，内存安全
- **SQLite**: 嵌入式关系数据库
- **Tokio**: 异步运行时，高并发支持
- **Reqwest**: HTTP客户端库
- **Serde**: 序列化/反序列化框架

#### 开发工具
- **pnpm**: 快速、节省空间的包管理器
- **Vitest**: 现代化的测试框架
- **ESLint + Prettier**: 代码质量和格式化
- **TypeScript**: 静态类型检查

## 开发环境搭建

### 系统要求

开发 ImgToss 需要以下系统环境：

| 组件 | 版本要求 | 备注 |
|------|----------|------|
| Node.js | 18.0+ | 推荐 20.x LTS |
| Rust | 1.70+ | 最新稳定版 |
| pnpm | 8.0+ | 包管理器 |
| Git | 2.0+ | 版本控制 |

### 详细安装步骤

#### 1. 安装 Node.js 和 pnpm

```bash
# 使用 nvm 安装 Node.js (推荐)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 20
nvm use 20

# 安装 pnpm
npm install -g pnpm

# 验证安装
node --version  # v20.x.x
pnpm --version  # 8.x.x
```

#### 2. 安装 Rust 工具链

```bash
# 安装 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.bashrc

# 验证安装
rustc --version  # rustc 1.70+
cargo --version  # cargo 1.70+

# 安装 Tauri CLI
cargo install tauri-cli --version \"^2.0.0\"
```

#### 3. 平台特定依赖

**Linux (Ubuntu/Debian):**
```bash
sudo apt update
sudo apt install libgtk-3-dev libwebkit2gtk-4.0-dev libssl-dev
```

**macOS:**
```bash
# 确保安装了 Xcode Command Line Tools
xcode-select --install
```

**Windows:**
```powershell
# 确保安装了 Microsoft C++ Build Tools
# 和 WebView2 Runtime
```

#### 4. 克隆和配置项目

```bash
# 克隆仓库
git clone https://github.com/your-repo/imgtoss.git
cd imgtoss

# 安装前端依赖
pnpm install

# 安装 Rust 依赖（自动执行）
cd src-tauri
cargo build
cd ..

# 验证开发环境
pnpm tauri dev
```

### 开发服务器

#### 启动开发环境
```bash
# 方式一: 同时启动前后端（推荐）
pnpm tauri dev

# 方式二: 分别启动
# 终端1 - 前端开发服务器
pnpm dev

# 终端2 - Tauri 开发模式
pnpm tauri dev --no-dev-server
```

#### 热重载支持
- **前端热重载**: Next.js 开发服务器提供即时热重载
- **后端热重载**: Rust 代码修改后需重启 Tauri
- **配置热重载**: `tauri.conf.json` 修改自动重启应用

## 项目结构详解

### 目录结构
```
imgtoss/
├── 📁 app/                     # Next.js App Router 页面
│   ├── dashboard/              # 仪表板页面
│   ├── image-upload/           # 图片上传页面  
│   ├── storage/               # 存储配置页面
│   ├── history/               # 历史记录页面
│   ├── globals.css            # 全局样式
│   ├── layout.tsx             # 根布局组件
│   └── page.tsx               # 首页
│
├── 📁 components/             # React 组件
│   ├── ui/                    # 基础 UI 组件 (Radix UI)
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   ├── dialog.tsx
│   │   └── ...
│   └── kokonutui/             # 业务组件
│       ├── dashboard.tsx      # 仪表板组件
│       ├── image-upload.tsx   # 上传组件
│       ├── storage-config.tsx # 配置组件
│       └── ...
│
├── 📁 lib/                    # 工具库和 API
│   ├── contexts/              # React Context
│   │   ├── app-state-context.tsx
│   │   └── theme-context.tsx
│   ├── hooks/                 # 自定义 Hooks
│   │   ├── use-progress-monitoring.ts
│   │   ├── use-app-config.ts
│   │   └── ...
│   ├── utils/                 # 工具函数
│   │   ├── cn.ts             # className 工具
│   │   ├── state-recovery.ts  # 状态恢复
│   │   └── ...
│   ├── __tests__/            # 前端测试
│   │   ├── tauri-integration.test.ts
│   │   └── ...
│   ├── tauri-api.ts          # Tauri API 封装
│   └── types.ts              # TypeScript 类型定义
│
├── 📁 src-tauri/             # Tauri 后端
│   ├── src/
│   │   ├── commands/          # Tauri 命令处理器
│   │   │   ├── mod.rs
│   │   │   ├── file_commands.rs
│   │   │   ├── upload_commands.rs
│   │   │   ├── config_commands.rs
│   │   │   └── tests.rs       # 后端测试
│   │   │
│   │   ├── services/          # 业务服务层
│   │   │   ├── mod.rs
│   │   │   ├── config_service.rs
│   │   │   ├── file_service.rs
│   │   │   ├── image_service.rs
│   │   │   ├── oss_service.rs
│   │   │   └── history_service.rs
│   │   │
│   │   ├── models/           # 数据模型
│   │   │   ├── mod.rs
│   │   │   ├── config.rs
│   │   │   ├── file.rs
│   │   │   └── history.rs
│   │   │
│   │   ├── utils/           # 工具模块
│   │   │   ├── mod.rs
│   │   │   ├── error.rs     # 错误处理
│   │   │   ├── crypto.rs    # 加密工具
│   │   │   └── validation.rs # 输入验证
│   │   │
│   │   ├── lib.rs           # 库入口
│   │   └── main.rs          # 应用入口
│   │
│   ├── Cargo.toml           # Rust 依赖配置
│   ├── tauri.conf.json      # Tauri 配置
│   ├── build.rs             # 构建脚本
│   └── icons/              # 应用图标
│
├── 📁 docs/                 # 项目文档
├── 📄 package.json          # Node.js 项目配置
├── 📄 tailwind.config.js    # Tailwind 配置
├── 📄 next.config.js        # Next.js 配置
├── 📄 tsconfig.json         # TypeScript 配置
└── 📄 README.md            # 项目说明
```

### 架构层次说明

#### 前端架构 (Next.js Layer)
```typescript
// app/layout.tsx - 根布局
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="zh-CN">
      <body className={inter.className}>
        <ThemeProvider>
          <AppStateProvider>
            {children}
          </AppStateProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}

// 页面组件通过 Tauri API 与后端通信
const uploadFile = async (file: File) => {
  const result = await uploadImage({
    filePath: file.path,
    configId: selectedConfig.id
  });
  return result;
};
```

#### 后端架构 (Tauri + Rust Layer)
```rust
// src-tauri/src/main.rs - 应用入口
fn main() {
    tauri::Builder::default()
        .plugin(tauri_plugin_stronghold::Builder::new().build())
        .invoke_handler(tauri::generate_handler![
            commands::upload_image,
            commands::scan_markdown_images,
            commands::get_upload_history,
            // ... 更多命令
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

// 命令层处理前端请求
#[tauri::command]
pub async fn upload_image(
    file_path: String,
    config_id: String,
) -> Result<UploadResult, String> {
    let service = ImageService::new();
    service.upload_image(file_path, config_id).await
        .map_err(|e| e.to_string())
}
```

### 通信机制

#### 前端到后端通信
```typescript
// lib/tauri-api.ts - 类型安全的 API 封装
import { invoke } from '@tauri-apps/api/tauri';

export interface UploadImageParams {
  filePath: string;
  configId: string;
}

export interface UploadResult {
  id: string;
  url: string;
  fileSize: number;
  uploadTime: string;
}

export async function uploadImage(
  params: UploadImageParams
): Promise<UploadResult> {
  return await invoke<UploadResult>('upload_image', params);
}
```

#### 后端到前端事件
```rust
// Rust 中发送事件到前端
use tauri::Manager;

#[tauri::command]
pub async fn start_batch_upload(
    app_handle: tauri::AppHandle,
    files: Vec<String>,
) -> Result<(), String> {
    for (index, file) in files.iter().enumerate() {
        // 上传逻辑...
        
        // 发送进度事件
        app_handle.emit_all("upload-progress", UploadProgress {
            file_index: index,
            progress: 0.5,
            bytes_uploaded: 1024,
            total_bytes: 2048,
        }).unwrap();
    }
    
    Ok(())
}
```

```typescript
// 前端监听后端事件
import { listen } from '@tauri-apps/api/event';

useEffect(() => {
  const unlisten = listen<UploadProgress>('upload-progress', (event) => {
    setUploadProgress(event.payload);
  });
  
  return () => {
    unlisten.then(fn => fn());
  };
}, []);
```

## API 设计规范

### 命令命名规范

所有 Tauri 命令使用 `snake_case` 命名，并按功能模块分组：

```rust
// 文件操作相关
scan_markdown_images
validate_file_path
get_file_info

// 上传操作相关  
upload_image
upload_batch_images
cancel_upload
get_upload_progress

// 配置管理相关
get_storage_configs
save_storage_config  
test_storage_connection
delete_storage_config

// 历史记录相关
get_upload_history
search_upload_history
export_upload_history
delete_history_record
```

### 类型定义规范

所有数据结构在 Rust 和 TypeScript 中保持一致：

```rust
// src-tauri/src/models/config.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    pub id: String,
    pub name: String,
    pub provider: StorageProvider,
    pub endpoint: String,
    pub region: String,
    pub bucket: String,
    pub access_key: String,
    pub secret_key: String,
    pub custom_path: Option<String>,
    pub is_default: bool,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StorageProvider {
    AliyunOSS,
    TencentCOS,
    AWSS3,
    CustomS3,
}
```

```typescript
// lib/types.ts
export interface StorageConfig {
  id: string;
  name: string;
  provider: StorageProvider;
  endpoint: string;
  region: string;
  bucket: string;
  accessKey: string;
  secretKey: string;
  customPath?: string;
  isDefault: boolean;
  createdAt: string;
}

export type StorageProvider = 
  | 'AliyunOSS'
  | 'TencentCOS' 
  | 'AWSS3'
  | 'CustomS3';
```

### 错误处理规范

#### 统一错误类型
```rust
// src-tauri/src/utils/error.rs
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("文件操作错误: {0}")]
    FileOperation(String),
    
    #[error("网络请求错误: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("配置错误: {0}")]
    Configuration(String),
    
    #[error("验证错误: {0}")]
    Validation(String),
    
    #[error("数据库错误: {0}")]
    Database(#[from] rusqlite::Error),
}

impl Serialize for AppError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}
```

#### 前端错误处理
```typescript
// lib/utils/error-handling.ts
export interface ApiError {
  message: string;
  code?: string;
  details?: Record<string, any>;
}

export function handleApiError(error: unknown): ApiError {
  if (typeof error === 'string') {
    return { message: error };
  }
  
  if (error instanceof Error) {
    return { message: error.message };
  }
  
  return { message: '未知错误' };
}

// 使用示例
try {
  const result = await uploadImage(params);
  return result;
} catch (error) {
  const apiError = handleApiError(error);
  toast.error(apiError.message);
  throw apiError;
}
```

## 开发规范和最佳实践

### 代码风格规范

#### TypeScript/React 规范
```typescript
// 1. 组件命名使用 PascalCase
export function ImageUploadDialog({ 
  open, 
  onOpenChange 
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  // 组件逻辑
}

// 2. Hook 使用 camelCase，以 use 开头
export function useUploadProgress(uploadId: string) {
  const [progress, setProgress] = useState(0);
  // Hook 逻辑
  return { progress };
}

// 3. 常量使用 UPPER_SNAKE_CASE
const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
const SUPPORTED_FORMATS = ['jpg', 'png', 'gif', 'webp'];

// 4. 接口定义使用 PascalCase
export interface UploadOptions {
  maxConcurrent: number;
  retryCount: number;
  autoRetry: boolean;
}
```

#### Rust 代码规范
```rust
// 1. 结构体使用 PascalCase
pub struct ImageService {
    config: StorageConfig,
    client: reqwest::Client,
}

// 2. 函数和变量使用 snake_case
impl ImageService {
    pub fn new(config: StorageConfig) -> Self {
        let client = reqwest::Client::new();
        Self { config, client }
    }
    
    pub async fn upload_image(&self, file_path: &str) -> Result<UploadResult> {
        let file_content = tokio::fs::read(file_path).await?;
        // 上传逻辑
        Ok(UploadResult { /* ... */ })
    }
}

// 3. 常量使用 UPPER_SNAKE_CASE
const MAX_UPLOAD_SIZE: usize = 50 * 1024 * 1024;
const DEFAULT_TIMEOUT: u64 = 30;
```

### 测试规范

#### 前端测试
```typescript
// lib/__tests__/tauri-integration.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { uploadImage } from '../tauri-api';

// Mock Tauri API
vi.mock('@tauri-apps/api/tauri', () => ({
  invoke: vi.fn(),
}));

describe('Tauri API Integration', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should upload image successfully', async () => {
    const mockResult = {
      id: 'test-id',
      url: 'https://example.com/image.jpg',
      fileSize: 1024,
      uploadTime: '2024-01-30T14:30:22Z'
    };
    
    vi.mocked(invoke).mockResolvedValue(mockResult);
    
    const result = await uploadImage({
      filePath: '/path/to/image.jpg',
      configId: 'config-id'
    });
    
    expect(result).toEqual(mockResult);
    expect(invoke).toHaveBeenCalledWith('upload_image', {
      filePath: '/path/to/image.jpg',
      configId: 'config-id'
    });
  });
});
```

#### 后端测试
```rust
// src-tauri/src/commands/tests.rs
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;
    use tokio_test;

    #[tokio::test]
    async fn test_validate_file_path() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.jpg");
        std::fs::write(&file_path, b"test content").unwrap();
        
        let result = validate_file_path(
            file_path.to_string_lossy().to_string()
        ).await;
        
        assert!(result.is_ok());
        let validation = result.unwrap();
        assert!(validation.exists);
        assert!(validation.is_readable);
    }

    #[tokio::test]
    async fn test_scan_markdown_images() {
        let temp_dir = tempdir().unwrap();
        let md_file = temp_dir.path().join("test.md");
        
        let content = r#"# Test Document
        ![Image 1](./images/photo.jpg)
        ![Image 2](../assets/logo.png)
        "#;
        
        std::fs::write(&md_file, content).unwrap();
        
        let result = scan_markdown_images(
            md_file.to_string_lossy().to_string()
        ).await;
        
        assert!(result.is_ok());
        let images = result.unwrap();
        assert_eq!(images.len(), 2);
    }
}
```

### 性能优化最佳实践

#### 前端性能优化
```typescript
// 1. 使用 React.memo 优化组件重渲染
export const ImageCard = React.memo(function ImageCard({
  image,
  onSelect,
  onRemove
}: ImageCardProps) {
  return (
    <div className="image-card">
      {/* 组件内容 */}
    </div>
  );
});

// 2. 使用 useMemo 缓存计算结果
function UploadList({ files }: { files: File[] }) {
  const totalSize = useMemo(() => {
    return files.reduce((sum, file) => sum + file.size, 0);
  }, [files]);

  const formattedSize = useMemo(() => {
    return formatFileSize(totalSize);
  }, [totalSize]);

  return <div>总大小: {formattedSize}</div>;
}

// 3. 使用 useCallback 优化事件处理函数
function ImageUpload() {
  const [files, setFiles] = useState<File[]>([]);

  const handleFileSelect = useCallback((newFiles: File[]) => {
    setFiles(prev => [...prev, ...newFiles]);
  }, []);

  const handleFileRemove = useCallback((fileId: string) => {
    setFiles(prev => prev.filter(f => f.id !== fileId));
  }, []);

  return (
    <FileDropzone 
      onFilesSelect={handleFileSelect}
      onFileRemove={handleFileRemove}
    />
  );
}
```

#### 后端性能优化
```rust
// 1. 使用连接池管理数据库连接
use tokio::sync::OnceCell;
use rusqlite::Connection;

static DB_POOL: OnceCell<Arc<Mutex<Connection>>> = OnceCell::const_new();

async fn get_db_connection() -> Result<Arc<Mutex<Connection>>, AppError> {
    DB_POOL
        .get_or_init(|| async {
            let conn = Connection::open("app.db")?;
            // 配置连接
            Ok(Arc::new(Mutex::new(conn)))
        })
        .await
}

// 2. 使用异步流处理大文件
use tokio_util::codec::{BytesCodec, FramedRead};

async fn upload_large_file(file_path: &str) -> Result<UploadResult, AppError> {
    let file = File::open(file_path).await?;
    let stream = FramedRead::new(file, BytesCodec::new());
    
    // 分块上传
    let mut upload_parts = Vec::new();
    pin_mut!(stream);
    
    while let Some(chunk) = stream.next().await {
        let chunk = chunk?;
        let part = upload_chunk(chunk).await?;
        upload_parts.push(part);
    }
    
    complete_multipart_upload(upload_parts).await
}

// 3. 批量操作优化数据库性能
async fn batch_insert_history(
    conn: &Connection,
    records: Vec<HistoryRecord>
) -> Result<(), AppError> {
    let mut stmt = conn.prepare(
        "INSERT INTO upload_history (id, filename, url, file_size, upload_time) 
         VALUES (?1, ?2, ?3, ?4, ?5)"
    )?;
    
    for record in records {
        stmt.execute(params![
            record.id,
            record.filename,
            record.url,
            record.file_size,
            record.upload_time,
        ])?;
    }
    
    Ok(())
}
```

## 构建和部署

### 开发构建
```bash
# 前端开发构建
pnpm build

# Tauri 开发构建
pnpm tauri build --debug

# 检查构建产物
ls -la src-tauri/target/debug/
```

### 生产构建
```bash
# 完整生产构建
pnpm tauri build

# 生成的文件位置：
# - Windows: src-tauri/target/release/bundle/msi/
# - macOS: src-tauri/target/release/bundle/dmg/
# - Linux: src-tauri/target/release/bundle/deb/ 或 appimage/
```

### 构建配置优化
```json
// tauri.conf.json
{
  "build": {
    "beforeBuildCommand": "pnpm build",
    "frontendDist": "../out"
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "identifier": "com.kieran.imgtoss",
    "category": "Developer Tool",
    "shortDescription": "现代化图像上传管理工具",
    "longDescription": "一款专为开发者和内容创作者设计的图像上传管理工具...",
    "resources": [
      "resources/*"
    ],
    "externalBin": [],
    "copyright": "2024, ImgToss Contributors",
    "licenseFile": "../LICENSE",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  }
}
```

### CI/CD 配置
```yaml
# .github/workflows/build.yml
name: Build and Release

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

jobs:
  test-tauri:
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-22.04, windows-latest]

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Rust setup
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.0-dev libssl-dev

      - name: Install frontend dependencies
        run: pnpm install

      - name: Run frontend tests
        run: pnpm test:run

      - name: Run Rust tests
        run: cd src-tauri && cargo test

      - name: Build the app
        run: pnpm tauri build

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}-app
          path: |
            src-tauri/target/release/bundle/*/
```

## 贡献指南

### 贡献流程

1. **Fork 仓库**: 在 GitHub 上 Fork ImgToss 仓库
2. **创建分支**: 基于 main 分支创建功能分支
   ```bash
   git checkout -b feature/awesome-feature
   ```
3. **开发功能**: 按照代码规范开发新功能
4. **编写测试**: 为新功能添加相应的测试用例
5. **提交代码**: 使用清晰的提交信息
   ```bash
   git commit -m "feat: 添加自动重复检测功能"
   ```
6. **推送分支**: 推送到您的 Fork 仓库
   ```bash
   git push origin feature/awesome-feature
   ```
7. **创建 PR**: 在 GitHub 上创建 Pull Request

### 提交信息规范

使用约定式提交 (Conventional Commits) 格式：

```
<类型>[可选 作用域]: <描述>

[可选 正文]

[可选 脚注]
```

**类型说明：**
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式修改
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

**示例：**
```bash
feat(upload): 添加批量上传进度条显示
fix(config): 修复配置保存时的加密问题
docs: 更新 API 文档和使用示例
```

### 代码审查清单

提交 PR 前请检查：

#### 功能性检查
- [ ] 新功能按预期工作
- [ ] 不会破坏现有功能
- [ ] 错误情况得到正确处理
- [ ] 用户界面友好且直观

#### 代码质量检查
- [ ] 遵循项目代码规范
- [ ] 添加了必要的注释
- [ ] 没有未使用的导入或变量
- [ ] 函数和类的职责单一

#### 测试检查
- [ ] 为新功能添加了测试用例
- [ ] 所有测试通过
- [ ] 测试覆盖了主要代码路径
- [ ] 包含边界条件测试

#### 文档检查
- [ ] 更新了相关文档
- [ ] API 变更有详细说明
- [ ] 添加了使用示例
- [ ] 更新了变更日志

### 开发环境建议

#### VS Code 扩展推荐
```json
// .vscode/extensions.json
{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "tauri-apps.tauri-vscode",
    "bradlc.vscode-tailwindcss",
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-typescript-next",
    "vitest.explorer"
  ]
}
```

#### VS Code 设置
```json
// .vscode/settings.json
{
  "rust-analyzer.linkedProjects": ["./src-tauri/Cargo.toml"],
  "typescript.preferences.importModuleSpecifier": "relative",
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[rust]": {
    "editor.defaultFormatter": "rust-lang.rust-analyzer"
  }
}
```

通过遵循本开发者指南，您可以高效地参与 ImgToss 的开发，为这个开源项目贡献自己的力量。如果您有任何问题，欢迎在 GitHub Issues 中提出或加入社区讨论。